<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue 3.0 进展分享（尤雨溪） | 第二届Vue.js开发者大会</title>
    <meta name="description" content="第二届Vue.js开发者大会">
    
    
    <link rel="preload" href="/doc/vueconf-2/assets/css/0.styles.7a919639.css" as="style"><link rel="preload" href="/doc/vueconf-2/assets/js/app.5d689939.js" as="script"><link rel="preload" href="/doc/vueconf-2/assets/js/9.bb6eac9f.js" as="script"><link rel="prefetch" href="/doc/vueconf-2/assets/js/10.1f8a27c7.js"><link rel="prefetch" href="/doc/vueconf-2/assets/js/11.e40e4bfd.js"><link rel="prefetch" href="/doc/vueconf-2/assets/js/12.2edbe9b4.js"><link rel="prefetch" href="/doc/vueconf-2/assets/js/13.322c5058.js"><link rel="prefetch" href="/doc/vueconf-2/assets/js/14.a4628608.js"><link rel="prefetch" href="/doc/vueconf-2/assets/js/15.5a7ce225.js"><link rel="prefetch" href="/doc/vueconf-2/assets/js/16.e7f9b7f6.js"><link rel="prefetch" href="/doc/vueconf-2/assets/js/17.4425fd00.js"><link rel="prefetch" href="/doc/vueconf-2/assets/js/2.03bd4ed3.js"><link rel="prefetch" href="/doc/vueconf-2/assets/js/3.b39a6301.js"><link rel="prefetch" href="/doc/vueconf-2/assets/js/4.77ecfd39.js"><link rel="prefetch" href="/doc/vueconf-2/assets/js/5.e30d415d.js"><link rel="prefetch" href="/doc/vueconf-2/assets/js/6.ff5773a2.js"><link rel="prefetch" href="/doc/vueconf-2/assets/js/7.b44f905e.js"><link rel="prefetch" href="/doc/vueconf-2/assets/js/8.55fdef04.js">
    <link rel="stylesheet" href="/doc/vueconf-2/assets/css/0.styles.7a919639.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/doc/vueconf-2/" class="home-link router-link-active"><!----> <span class="site-name">第二届Vue.js开发者大会</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/doc/vueconf-2/" class="nav-link">主页</a></div><div class="nav-item"><a href="/doc/vueconf-2/subject/" class="nav-link router-link-active">日程</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/doc/vueconf-2/" class="nav-link">主页</a></div><div class="nav-item"><a href="/doc/vueconf-2/subject/" class="nav-link router-link-active">日程</a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>日程</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/doc/vueconf-2/subject/vue3.html" class="active sidebar-link">vue 3.0 进展分享（尤雨溪）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/doc/vueconf-2/subject/vue3.html#更快" class="sidebar-link">更快</a></li><li class="sidebar-sub-header"><a href="/doc/vueconf-2/subject/vue3.html#更小" class="sidebar-link">更小</a></li><li class="sidebar-sub-header"><a href="/doc/vueconf-2/subject/vue3.html#更易于维护" class="sidebar-link">更易于维护</a></li><li class="sidebar-sub-header"><a href="/doc/vueconf-2/subject/vue3.html#更好的多端渲染支持" class="sidebar-link">更好的多端渲染支持</a></li><li class="sidebar-sub-header"><a href="/doc/vueconf-2/subject/vue3.html#新功能" class="sidebar-link">新功能</a></li><li class="sidebar-sub-header"><a href="/doc/vueconf-2/subject/vue3.html#关于ie" class="sidebar-link">关于IE</a></li></ul></li><li><a href="/doc/vueconf-2/subject/vueDeclarative.html" class="sidebar-link">Vue声明式编程(winter)</a></li><li><a href="/doc/vueconf-2/subject/vueCli.html" class="sidebar-link">What I Learned from Maintaining Vue CLI(蒋豪群)</a></li><li><a href="/doc/vueconf-2/subject/vue-weiyuanyue.html" class="sidebar-link">燃烧你的 CLI(韦元悦)</a></li><li><a href="/doc/vueconf-2/subject/vue-heshijun.html" class="sidebar-link">JS class fields &amp; Vue(贺师俊)</a></li><li><a href="/doc/vueconf-2/subject/vueAccessible.html" class="sidebar-link">Making Your Vue App Accessible(勾三股四)</a></li><li><a href="/doc/vueconf-2/subject/vue-tangjinzhou.html" class="sidebar-link">探索Vue的高级应用-Ant Design Vue里的那些黑科技(唐金州)</a></li><li><a href="/doc/vueconf-2/subject/vueElectron.html" class="sidebar-link">基于Electron Vue的桌面应用开发实践(赵帅)</a></li><li><a href="/doc/vueconf-2/subject/vueHippy.html" class="sidebar-link">多端统一方案 Hippy-Vue 是如何设计实现的(旷旭卿)</a></li><li><a href="/doc/vueconf-2/subject/vue-zhuoling.html" class="sidebar-link">应用多端统一的实践(卓凌)</a></li><li><a href="/doc/vueconf-2/subject/vueSSR.html" class="sidebar-link">再谈Vue SSR -- 响应式数据流在快手游戏直播中的应用(天翔)</a></li><li><a href="/doc/vueconf-2/subject/vueCRDT.html" class="sidebar-link">how CRDT improves Vue apps(Andrey Sitnik)</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="vue-3-0-进展分享（尤雨溪）"><a href="#vue-3-0-进展分享（尤雨溪）" aria-hidden="true" class="header-anchor">#</a> vue 3.0 进展分享（尤雨溪）</h1> <ul><li>大家可以直接前往观看尤大大的<a href="https://www.bilibili.com/video/av36787459/" target="_blank" rel="noopener noreferrer">在线视频<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://img.w3ctech.com/Vue3.0Updates.pdf" target="_blank" rel="noopener noreferrer">在线PPT<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="更快"><a href="#更快" aria-hidden="true" class="header-anchor">#</a> 更快</h2> <ul><li>Vitrual DOM完全重构，初始渲染/更新提速达100%</li> <li>更多编译时的优化，以减少运行时的开销
<ul><li>原来Vitrual DOM对于很多不会变动的节点，不可避免的要重新生成比对，现在通过编译时进行分析解决</li> <li>原来Vitrual DOM会直接将template中的代码作为字符串生成对应的Vitrual DOM代码，而在代码运行中去判断是否为原生标签还是组件，现在在编译时直接判断，如果是远程标签直接生成原生的Vitrual DOM</li> <li>函数调用尽可能有同样个数的参数，这样会更易于被JS引擎去优化</li> <li>在模板中直接静态的分析一个元素所包含的子元素的类型</li> <li>优化slots的生成，数据更新时，首先要更新父组件，父组件更新同时生成新的slot内容传到子组件，然后子组件也更新，意味着同时触发两个组件更新，现在都跟scope slot一样统一成为一个lazy的函数，当你把函数传给子组件之后，由子组件来决定什么时候调用这个函数，当子组件调用函数的时候，就只需要重新渲染子组件。</li> <li>静态内容提取，这部分内容直接提取出来，模板可以直接复用Vitrual DOM，连比对的dom树也直接跳过<div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- Template --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>foo<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>bar<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  {{ text }}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//  Compiler output</span>
<span class="token keyword">const</span> __props1<span class="token operator">=</span><span class="token punctuation">{</span>
  id<span class="token punctuation">:</span><span class="token string">'foo'</span><span class="token punctuation">,</span>
  <span class="token keyword">class</span><span class="token punctuation">:</span><span class="token string">'bar'</span>
<span class="token punctuation">}</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span>__props1<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>text<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>内联事件函数提取，每次数据更新时都会生成新的函数,现在将函数cache起来<div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- Template --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Comp</span> <span class="token attr-name">@event</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>count++<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//  Compiler output</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> getBoundMethod <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">function</span> <span class="token function">__fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span>
<span class="token punctuation">}</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>Comp<span class="token punctuation">,</span><span class="token punctuation">{</span>
    onEvent<span class="token punctuation">:</span><span class="token function">getBoundMethod</span><span class="token punctuation">(</span>__fn1<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>基于<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener noreferrer">Proxy<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的数据监听系统
<ul><li><p>基于Proxy的新数据监听系统 全语言特性 + 更好的性能</p></li> <li><p>Vue 2用的是基于ES5的getter/setter，也就是Object.defineProperty的API。Vue 3里面基于proxy实现新的数据监听系统，可以将以下四点都支持。</p> <ol><li>对象属性增添/删除</li> <li>数组index/length更改</li> <li>Map,Set,WeakMap,WeakSet</li> <li>Classes</li></ol></li> <li><p>这个监听是所谓的Lazy by default,就是当只有一个数据被使用的时候，才会去监听他</p></li> <li><p>利用Proxy减少组件实例初始化开销，原来大量的Object.defineProperty是比较昂贵的开销,Vue 3中直接暴露的this,其实是一个真正的组件实例的一个Proxy，然后是当你实在这个Proxy上获取一些属性的时候，内部判断后避免了Object.defineProperty使用</p></li></ul></li></ul></li></ul> <h2 id="更小"><a href="#更小" aria-hidden="true" class="header-anchor">#</a> 更小</h2> <ul><li>便于Tree-shaking的代码结构,Tree-shaking就是把没用的代码在最后编译的时候给扔掉，之前Vue的整个代码，只有一个Vue对象进来，所有东西都在里面。Vue 3中对以下做成了按需引入(ES module imports)，新的最小核心运行时：~10kb gzipped
<ul><li>内置组件(keep-alive,transition...)</li> <li>指令的运行时 helper(v-model,v-for...)</li> <li>各种工具函数(asyncComponent,mixins,memoize...)</li></ul></li></ul> <h2 id="更易于维护"><a href="#更易于维护" aria-hidden="true" class="header-anchor">#</a> 更易于维护</h2> <ul><li>这是对于vue开发人员来说的</li> <li>从Flow迁移到TypeScript</li> <li>编译器重构
<ul><li>插件化设计</li> <li>带位置信息的parser(source maps!)</li> <li>为更好的IDE工具链铺路</li></ul></li></ul> <h2 id="更好的多端渲染支持"><a href="#更好的多端渲染支持" aria-hidden="true" class="header-anchor">#</a> 更好的多端渲染支持</h2> <ul><li>Custom Render API<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> createRenderer <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@vue/runtime-core'</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  nodeOps<span class="token punctuation">,</span>
  patchData
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li></ul> <h2 id="新功能"><a href="#新功能" aria-hidden="true" class="header-anchor">#</a> 新功能</h2> <ul><li>响应式数据监听 API<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> observable<span class="token punctuation">,</span> effect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  nodeOps<span class="token punctuation">,</span>
  patchData
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li> <li>轻松排查组件更新原因
写上debugger，就可以直接看到是那一行触发的更新<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> Comp<span class="token operator">=</span><span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span>props<span class="token punctuation">.</span>count<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">renderTiggered</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">debugger</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>更好的TypeScript支持，包括原声的Class API 和TSX</li></ul> <ul><li><p>更好的警告信息</p> <ul><li>组件堆栈包含函数式组件</li> <li>可以直接在警告中查看组件的props</li> <li>在更多的警告中提供组件堆栈信息</li></ul></li> <li><p>Experimental Hooks API</p> <ul><li>作为一种逻辑复用机制，大概率取代mixins，尤大大实验性质的<a href="https://github.com/yyx990803/vue-hooks" target="_blank" rel="noopener noreferrer">库链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></li> <li><p>Experimental Time Slicing Suppot</p> <ul><li>把javascript计算切割成一帧一帧（每16ms）的去运行，防止javascript运算量很大时导致浏览器线程阻塞而不能响应用户的操作</li> <li>我个人也试着用requestAnimationFrame原理实现了一下，有兴趣的可以查看一下<a href="https://github.com/Javison666/vue-timeSlicing-demo" target="_blank" rel="noopener noreferrer">个人的github地址<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></li></ul> <h2 id="关于ie"><a href="#关于ie" aria-hidden="true" class="header-anchor">#</a> 关于IE</h2> <ul><li>会有一个专门的版本，在IE中自动降级为旧的getter／setter机制，并对IE中不支持的用法给出警告（IE9、IE10理论上微软都已经宣判他们完蛋了，IE11还有好多年好多年好多年...）</li></ul></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/doc/vueconf-2/subject/vueDeclarative.html">
          Vue声明式编程(winter)
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/doc/vueconf-2/assets/js/9.bb6eac9f.js" defer></script><script src="/doc/vueconf-2/assets/js/app.5d689939.js" defer></script>
  </body>
</html>
